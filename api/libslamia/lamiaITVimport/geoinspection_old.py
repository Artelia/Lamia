# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeoInspection
								 A QGIS plugin
 Cartographie des defauts observes lors d'inpections de reseaux EU/EP
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
							  -------------------
		begin				 : 2018-10-05
		git sha				 : $Format:%H$
		copyright			 : (C) 2018 by Artelia Ville & Transport
		email				 : laurent.tavernier@arteliagroup.com
 ***************************************************************************/

/***************************************************************************
 *																		   *
 *	 This program is free software; you can redistribute it and/or modify  *
 *	 it under the terms of the GNU General Public License as published by  *
 *	 the Free Software Foundation; either version 2 of the License, or	   *
 *	 (at your option) any later version.								   *
 *																		   *
 ***************************************************************************/
"""
from PyQt5.QtCore import * #QSettings, QTranslator, qVersion, QCoreApplication
#from PyQt5.QtCore import pyqtSignal, QObject, QFileInfo, QDate, QTime, QDateTime, Qt, QVariant
from PyQt5.QtGui import * #QIcon
from PyQt5.QtWidgets import * #QAction, QApplication, QWidget, QInputDialog, QLineEdit, QFileDialog
from qgis.core import * #QgsApplication, QgsProject, QgsVectorLayer, QgsCoordinateReferenceSystem, QgsCoordinateTransform
from qgis.utils import *
import sys
import os
import os.path
import shutil
import tempfile
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .geoinspection_dialog import GeoInspectionDialog
import os.path


class GeoInspection:
	"""QGIS Plugin Implementation."""

	def __init__(self, iface):
		"""Constructor.

		:param iface: An interface instance that will be passed to this class
			which provides the hook by which you can manipulate the QGIS
			application at run time.
		:type iface: QgsInterface
		"""
		# Save reference to the QGIS interface
		self.iface = iface
		# initialize plugin directory
		self.plugin_dir = os.path.dirname(__file__)
		# initialize locale
		locale = QSettings().value('locale/userLocale')[0:2]
		locale_path = os.path.join(
			self.plugin_dir,
			'i18n',
			'GeoInspection_{}.qm'.format(locale))

		if os.path.exists(locale_path):
			self.translator = QTranslator()
			self.translator.load(locale_path)

			if qVersion() > '4.3.3':
				QCoreApplication.installTranslator(self.translator)

		# Create the dialog (after translation) and keep reference
		self.dlg = GeoInspectionDialog()

		# Declare instance attributes
		self.actions = []
		self.menu = self.tr(u'&Geo Inspection')
		# TODO: We are going to let the user set this up in a future iteration
		self.toolbar = self.iface.addToolBar(u'GeoInspection')
		self.toolbar.setObjectName(u'GeoInspection')

	# noinspection PyMethodMayBeStatic
	def tr(self, message):
		"""Get the translation for a string using Qt translation API.

		We implement this ourselves since we do not inherit QObject.

		:param message: String for translation.
		:type message: str, QString

		:returns: Translated version of message.
		:rtype: QString
		"""
		# noinspection PyTypeChecker,PyArgumentList,PyCallByClass
		return QCoreApplication.translate('GeoInspection', message)


	def add_action(
		self,
		icon_path,
		text,
		callback,
		enabled_flag=True,
		add_to_menu=True,
		add_to_toolbar=True,
		status_tip=None,
		whats_this=None,
		parent=None):
		"""Add a toolbar icon to the toolbar.

		:param icon_path: Path to the icon for this action. Can be a resource
			path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
		:type icon_path: str

		:param text: Text that should be shown in menu items for this action.
		:type text: str

		:param callback: Function to be called when the action is triggered.
		:type callback: function

		:param enabled_flag: A flag indicating if the action should be enabled
			by default. Defaults to True.
		:type enabled_flag: bool

		:param add_to_menu: Flag indicating whether the action should also
			be added to the menu. Defaults to True.
		:type add_to_menu: bool

		:param add_to_toolbar: Flag indicating whether the action should also
			be added to the toolbar. Defaults to True.
		:type add_to_toolbar: bool

		:param status_tip: Optional text to show in a popup when mouse pointer
			hovers over the action.
		:type status_tip: str

		:param parent: Parent widget for the new action. Defaults None.
		:type parent: QWidget

		:param whats_this: Optional text to show in the status bar when the
			mouse pointer hovers over the action.

		:returns: The action that was created. Note that the action is also
			added to self.actions list.
		:rtype: QAction
		"""

		icon = QIcon(icon_path)
		action = QAction(icon, text, parent)
		action.triggered.connect(callback)
		action.setEnabled(enabled_flag)

		if status_tip is not None:
			action.setStatusTip(status_tip)

		if whats_this is not None:
			action.setWhatsThis(whats_this)

		if add_to_toolbar:
			self.toolbar.addAction(action)

		if add_to_menu:
			self.iface.addPluginToMenu(
				self.menu,
				action)

		self.actions.append(action)

		return action

	def initGui(self):
		"""Create the menu entries and toolbar icons inside the QGIS GUI."""

		icon_path = ':/plugins/GeoInspection/icon.png'
		self.add_action(
			icon_path,
			text=self.tr(u'Geo Inspection'),
			callback=self.run,
			parent=self.iface.mainWindow())


	def unload(self):
		"""Removes the plugin menu item and icon from QGIS GUI."""
		for action in self.actions:
			self.iface.removePluginMenu(
				self.tr(u'&Geo Inspection'),
				action)
			self.iface.removeToolBarIcon(action)
		# remove the toolbar
		del self.toolbar


#######################################################################################################################################################
## LTA - 05/10/2018 - Convert plugin QGIS 2.xx to 3.xx
#######################################################################################################################################################

#------------------------------------------------------------------------------------------------------------------------------------------------------
# Run
#------------------------------------------------------------------------------------------------------------------------------------------------------

	def run(self):
		# Masquage de différents éléments
		self.dlg.progress.hide()
		self.dlg.plus.hide()
		self.dlg.minus.hide()
		self.dlg.exit.hide()
		self.dlg.amont.hide()
		self.dlg.aval.hide()
		self.dlg.label_5.hide()
		# Définition de l'arborescence par défaut
		self.init_arbo = u""

		self.init_combo_amont=0
		self.init_combo_aval=0

		# Initialisation de la liste des entreprises dans le combo
		self.dlg.company.setEditable(False)
		self.dlg.company.clear()
		list_combo = [u"n/a"]
		list_company = []
		# Lecture de la liste de(s) entreprise(s) déclarées dans le fichier de sauvegarde
		file = open(self.plugin_dir+"\\templates\\liste_entreprise.txt", "r")
		for line in file:
			list_company.append(line.strip())
		file.close()
		list_company.sort()
		list_combo.extend(list_company)
		self.dlg.company.addItems(list_combo)

		# Affichage du dialogue principal
		self.dlg.show()

		# Connexion boutons
		self.dlg.config.clicked.connect(self.config_company)
		self.dlg.plus.clicked.connect(self.add_company)
		self.dlg.minus.clicked.connect(self.delete_company)
		self.dlg.company.editTextChanged.connect(self.new_company)
		self.dlg.addshp.clicked.connect(self.select_input_shp)
		self.dlg.amont.highlighted.connect(self.combo_field_amont)
		self.dlg.aval.highlighted.connect(self.combo_field_aval)
		self.dlg.addfile.clicked.connect(self.select_input_file)
		self.dlg.clearfile.clicked.connect(self.clear_input_file)
		self.dlg.addshp.clicked.connect(self.display_process)
		self.dlg.amont.highlighted.connect(self.display_process)
		self.dlg.aval.highlighted.connect(self.display_process)
		self.dlg.addfile.clicked.connect(self.display_process)
		self.dlg.config.clicked.connect(self.display_process)
		self.dlg.clearfile.clicked.connect(self.display_process)
		self.dlg.ok.clicked.connect(self.process)
		self.dlg.cancel.clicked.connect(self.exit)
		self.dlg.exit.clicked.connect(self.exit)
		self.dlg.rejected.connect(self.exit)

#------------------------------------------------------------------------------------------------------------------------------------------------------
# Gestion Entreprise
#------------------------------------------------------------------------------------------------------------------------------------------------------

	def config_company(self):
		# Vérification de l'état de la combobox
		if self.dlg.company.isEditable() == True:
			self.dlg.company.setEditable(False)
			self.dlg.plus.hide()
			self.dlg.minus.hide()
			# Enregistrement de la liste des entreprises du combo
			file = open(self.plugin_dir+"\\templates\\liste_entreprise.txt", "w")
			text = u""
			total = self.dlg.company.count()-1
			count = 0
			list_company = []
			while count <= total:
				if self.dlg.company.itemText(count) != u"n/a":
					text=text+self.dlg.company.itemText(count).strip()+u"\n"
				count = count + 1
			file.writelines(text)
			file.close()
			# Initialisation de la liste des entreprises dans le combo
			self.dlg.company.clear()
			list_combo = [u"n/a"]
			list_company = []
			# Lecture de la liste de(s) entreprise(s) déclarées dans le fichier de sauvegarde
			file = open(self.plugin_dir+"\\templates\\liste_entreprise.txt", "r")
			for line in file:
				list_company.append(line.strip())
			file.close()
			list_combo.extend(list_company)
			list_company.sort()
			self.dlg.company.addItems(list_combo)
		else:
			self.dlg.company.setEditable(True)
			self.dlg.plus.show()
			self.dlg.minus.show()

	def add_company(self):
		self.dlg.company.insertItem((self.dlg.company.count() + 1), u"")
		self.dlg.company.setCurrentIndex(self.dlg.company.count()-1)

	def delete_company(self):
		for_suppr = self.dlg.company.currentIndex()
		total = self.dlg.company.count()-1
		count = 1
		list_company = []
		while count <= total:
			if count != for_suppr:
				list_company.append(self.dlg.company.itemText(count).strip())
			count = count + 1
		list_company.sort()
		list_combo = [u"n/a"]
		list_combo.extend(list_company)
		self.dlg.company.clear()
		self.dlg.company.addItems(list_combo)

	def new_company(self):
		self.dlg.company.setItemText(self.dlg.company.currentIndex(), self.dlg.company.currentText())

#------------------------------------------------------------------------------------------------------------------------------------------------------
# Gestion SHP
#------------------------------------------------------------------------------------------------------------------------------------------------------

	def select_input_shp(self):
		self.shpname = QFileDialog.getOpenFileName(None,u"Sélectionner le SHP de référence",self.init_arbo, "*.shp *.tab")
		if self.shpname[0]==u"":
			if self.dlg.shp.displayText()==u"":
				self.dlg.shp.setEnabled(False)
				self.dlg.amont.hide()
				self.dlg.aval.hide()
				self.dlg.label_5.hide()
		else:
			self.dlg.shp.setEnabled(True)
			self.dlg.shp.setText(self.shpname[0])
			self.init_arbo = os.path.dirname(self.shpname[0])
			self.dlg.amont.show()
			self.dlg.aval.show()
			self.dlg.amont.addItem(u"Regard amont")
			self.dlg.aval.addItem(u"Regard aval")
			self.dlg.label_5.show()

			self.layer = QgsVectorLayer(self.dlg.shp.displayText(), "temp_troncon", "ogr")
			for field in self.layer.fields():
				self.dlg.amont.addItem(field.name())
				self.dlg.aval.addItem(field.name())

	def combo_field_amont(self):
		if self.init_combo_amont==0:
			self.dlg.amont.clear()
			for field in self.layer.fields():
				self.dlg.amont.addItem(field.name())
				self.dlg.aval.addItem(field.name())
				self.init_combo_amont=1

	def combo_field_aval(self):
		if self.init_combo_aval==0:
			self.dlg.aval.clear()
			for field in self.layer.fields():
				self.dlg.amont.addItem(field.name())
				self.dlg.aval.addItem(field.name())
				self.init_combo_aval=1

#------------------------------------------------------------------------------------------------------------------------------------------------------
# Gestion CSV/TXT
#------------------------------------------------------------------------------------------------------------------------------------------------------

	def select_input_file(self):
		self.filename = QFileDialog.getOpenFileNames(None,u"Sélectionner les ITV à traiter",self.init_arbo, "*.txt *.csv")
		if self.filename[0]==[]:
			if self.dlg.selection.count()==0:
				self.dlg.selection.setEnabled(False)
				self.dlg.ok.setEnabled(False)
				self.dlg.label_3.setEnabled(False)
				self.dlg.clearfile.setEnabled(False)
		else:
			self.dlg.selection.setEnabled(True)
			self.dlg.label_3.setEnabled(True)
			self.dlg.clearfile.setEnabled(True)
			for file in self.filename[0]:
				self.dlg.selection.addItem(file)
				self.init_arbo = os.path.dirname(file)

	def clear_input_file(self):
		self.dlg.selection.clear()
		self.dlg.selection.setEnabled(False)
		self.dlg.ok.setEnabled(False)
		self.dlg.label_3.setEnabled(False)
		self.dlg.clearfile.setEnabled(False)

#------------------------------------------------------------------------------------------------------------------------------------------------------
# Process
#------------------------------------------------------------------------------------------------------------------------------------------------------

	def display_process(self):
		if self.dlg.shp.text()==u"" or self.dlg.selection.count()==0 or self.dlg.amont.currentText()==u"Regard amont" or self.dlg.aval.currentText()==u"Regard aval" or self.dlg.company.isEditable() == True:
			self.dlg.ok.setEnabled(False)
		else:
			self.dlg.ok.setEnabled(True)

	def process(self):
		self.dlg.progress.show()
		# Affichage d'une barre de message
		# type de barre : pushCritical, pushInfo, pushSuccess, pushWarning
		msgbar = self.iface.messageBar()
		msgbar.pushMessage(u"Geo Inspection : ", u"Démarrage du traitement.", Qgis.Info,1)

#******************************************************************************************************************************************************
# Dépouillement des CSV/TXT
#******************************************************************************************************************************************************

		# Définition du nombre total de rapports ITV à traiter
		total = self.dlg.selection.count()
		countfile = 0

		# Recuperer l arborescence du dossier temporaire
		self.dossier_temp = tempfile.gettempdir()

		# Création d'un CSV output
		date = QDate().currentDate().toString('yyyy/MM/dd') # date forme us
		date = date.replace(u"/", u"")
		heure = QTime().currentTime().toString('hh:mm:ss') # heure:minutes:secondes
		heure = heure.replace(u":", u"")
		t_output = str(self.dossier_temp+"\\rapport_ITV_"+date+"_"+heure+".csv")

		# Ouvrir le CSV output en ecriture
		t_export_result = codecs.open(t_output, "w", encoding = 'utf-8')
		#t_export_result.writelines("AAD;AAF;AAB;AAK;AAJ;AAN;AAQ;AAL;ABF;ABH;var_entreprise;ABA;ABE;ABP;ACM;ACA;ACB;ACD;ACH;ACI;ACJ;ACK;ADA;ADC;var_encode"+"\n")
		t_export_result.writelines(u"id;regard_1;regard_2;reg_depart;sens;adresse;ville;foncier;emplacemnt;date_ins;nom_ins;entreprise;norme;methode;objet;nettoyage;forme;hauteur;materiau;prof_reg_1;prof_reg_2;type;utilisat;precipit;debit;encodage;dist_reg_1;code;carac_1;carac_2;remarque"+u"\n")

		var_entreprise = self.dlg.company.currentText()
		idline = 1

		# Boucle sur le(s) fichier(s) à traiter
		while countfile <= total-1:
			# Déclaration de valeurs par défaut de variables
			step1 = 0
			step2 = 0
			step3 = 0
			step4 = 0
			step5 = 0
			step6 = 0
			iAAB = 9999
			iAAD = 9999
			iAAF = 9999
			iAAJ = 9999
			iAAK = 9999
			iAAL = 9999
			iAAN = 9999
			iAAQ = 9999
			iABE = 9999
			iABF = 9999
			iABH = 9999
			iABP = 9999
			iABA = 9999
			iACM = 9999
			iACA = 9999
			iACB = 9999
			iACD = 9999
			iACH = 9999
			iACI = 9999
			iACJ = 9999
			iACK = 9999
			iADA = 9999
			iADC = 9999
			iI = 9999
			iA = 9999
			iB = 9999
			iC = 9999
			iF = 9999

			countline = 0
			#QMessageBox.warning(None, u"Attention", self.dlg.selection.item(countfile).text(), QMessageBox.Ok)
			# Ouverture du fichier courant à traiter
			file = codecs.open(self.dlg.selection.item(countfile).text(), "r", encoding = 'latin-1')
			# Boucle sur le(s) ligne(s) à traiter
			for line in file:
				if line[:2]==u"#Z":
					step5 = 0
					step6 = 1
					iI = 9999
					iA = 9999
					iB = 9999
					iC = 9999
					iF = 9999

				if step1 == 1:
					col=line.split(";")
					if iAAB != 9999:
						AAB=col[iAAB].replace(u"\"", u"").strip()
					else:
						AAB = u""
					if iAAD != 9999:
						AAD=col[iAAD].replace(u"\"", u"").strip()
					else:
						AAD = u""
					if iAAF != 9999:
						AAF=col[iAAF].replace(u"\"", u"").strip()
					else:
						AAF = u""
					if iAAJ != 9999:
						AAJ=col[iAAJ].replace(u"\"", u"").strip()
					else:
						AAJ = u""
					if iAAK != 9999:
						AAK=col[iAAK].replace(u"\"", u"").strip()
					else:
						AAK = u""
					if iAAL != 9999:
						AAL=col[iAAL].replace(u"\"", u"").strip()
					else:
						AAL = u""
					if iAAN != 9999:
						AAN=col[iAAN].replace(u"\"", u"").strip()
					else:
						AAN = u""
					if iAAQ != 9999:
						AAQ=col[iAAQ].replace(u"\"", u"").strip()
					else:
						AAQ = u""
					step1=0
					iAAB = 9999
					iAAD = 9999
					iAAF = 9999
					iAAJ = 9999
					iAAK = 9999
					iAAL = 9999
					iAAN = 9999
					iAAQ = 9999
				if step2 == 1:
					col=line.split(";")
					if iABE != 9999:
						ABE=col[iABE].replace(u"\"", u"").strip()
					else:
						ABE = u""
					if iABF != 9999:
						ABF=col[iABF].replace(u"\"", u"").strip()
					else:
						ABF = u""
					if iABH != 9999:
						ABH=col[iABH].replace(u"\"", u"").strip()
					else:
						ABH = u""
					if iABP != 9999:
						ABP=col[iABP].replace(u"\"", u"").strip()
					else:
						ABP = u""
					if iABA != 9999:
						ABA=col[iABA].replace(u"\"", u"").strip()
					else:
						ABA = u""
					step2=0
					iABE = 9999
					iABF = 9999
					iABH = 9999
					iABP = 9999
					iABA = 9999
				if step3 == 1:
					col=line.split(";")
					if iACM != 9999:
						ACM=col[iACM].replace(u"\"", u"").strip()
					else:
						ACM = u""
					if iACA != 9999:
						ACA=col[iACA].replace(u"\"", u"").strip()
					else:
						ACA = u""
					if iACB != 9999:
						ACB=col[iACB].replace(u"\"", u"").strip()
					else:
						ACB = u""
					if iACD != 9999:
						ACD=col[iACD].replace(u"\"", u"").strip()
					else:
						ACD = u""
					if iACH != 9999:
						ACH=col[iACH].replace(u"\"", u"").strip()
					else:
						ACH = u""
					if iACI != 9999:
						ACI=col[iACI].replace(u"\"", u"").strip()
					else:
						ACI = u""
					if iACJ != 9999:
						ACJ=col[iACJ].replace(u"\"", u"").strip()
					else:
						ACJ = u""
					if iACK != 9999:
						ACK=col[iACK].replace(u"\"", u"").strip()
					else:
						ACK = u""
					step3=0
					iACM = 9999
					iACA = 9999
					iACB = 9999
					iACD = 9999
					iACH = 9999
					iACI = 9999
					iACJ = 9999
					iACK = 9999
				if step4 == 1:
					col=line.split(";")
					if iADA != 9999:
						ADA=col[iADA].replace(u"\"", u"").strip()
					else:
						ADA = u""
					if iADC != 9999:
						ADC=col[iADC].replace(u"\"", u"").strip()
					else:
						ADC = u""
					step4=0
					iADA = 9999
					iADC = 9999
				if step5 == 1:
					col=line.split(";")
					if iI != 9999:
						I=col[iI].replace(u"\"", u"").strip()
					else:
						I = u""
					if iA != 9999:
						A=col[iA].replace(u"\"", u"").strip()
					else:
						A = u""
					if iB != 9999:
						B=col[iB].replace(u"\"", u"").strip()
					else:
						B = u""
					if iC != 9999:
						C=col[iC].replace(u"\"", u"").strip()
					else:
						C = u""
					if iF != 9999:
						F=col[iF].replace(u"\"", u"").strip()
					else:
						F = u""
					newrow = str(idline)+u";"+AAD+u";"+AAF+u";"+AAB+u";"+AAK+u";"+AAJ+u";"+AAN+u";"+AAQ+u";"+AAL+u";"+ABF+u";"+ABH+u";"+var_entreprise+u";"+ABA+u";"+ABE+u";"+ABP+u";"+ACM+u";"+ACA+u";"+ACB+u";"+ACD+u";"+ACH+u";"+ACI+u";"+ACJ+u";"+ACK+u";"+ADA+u";"+ADC+u";"+var_encode+u";"+I+u";"+A+u";"+B+u";"+C+u";"+F+u";"+u"\n"
					#QMessageBox.warning(None, u"Attention", str(newrow), QMessageBox.Ok)
					t_export_result.writelines(newrow)
					idline = idline + 1

				if line[:4]==u"#A1=":
					var_encode = line[4:].replace(u"\n", u"").strip()
				if line[:5]==u"#B01=":
					step1 = 1
					line = line.replace(u"#B01=", u"")
					col=line.split(";")
					index=0
					for c in col:
						if c == u"AAB":
							iAAB = index
						if c == u"AAD":
							iAAD = index
						if c == u"AAF":
							iAAF = index
						if c == u"AAJ":
							iAAJ = index
						if c == u"AAK":
							iAAK = index
						if c == u"AAL":
							iAAL = index
						if c == u"AAN":
							iAAN = index
						if c == u"AAQ":
							iAAQ = index
						index = index + 1
				if line[:5]==u"#B02=":
					step2 = 1
					line = line.replace(u"#B02=", u"")
					col=line.split(";")
					index=0
					for c in col:
						if c == u"ABE":
							iABE = index
						if c == u"ABF":
							iABF = index
						if c == u"ABH":
							iABH = index
						if c == u"ABP":
							iABP = index
						if c == u"ABA":
							iABA = index
						index = index + 1
				if line[:5]==u"#B03=":
					step3 = 1
					line = line.replace(u"#B03=", u"")
					col=line.split(";")
					index=0
					for c in col:
						if c == u"ACM":
							iACM = index
						if c == u"ACA":
							iACA = index
						if c == u"ACB":
							iACB = index
						if c == u"ACD":
							iACD = index
						if c == u"ACH":
							iACH = index
						if c == u"ACI":
							iACI = index
						if c == u"ACJ":
							iACJ = index
						if c == u"ACK":
							iACK = index
						index = index + 1
				if line[:5]==u"#B04=":
					step4 = 1
					line = line.replace(u"#B04=", u"")
					col=line.split(";")
					index=0
					for c in col:
						if c == u"ADA":
							iADA = index
						if c == u"ADC":
							iADC = index
						index = index + 1
				if line[:3]==u"#C=":
					step5 = 1
					line = line.replace(u"#C=", u"")
					col=line.split(";")
					index=0
					for c in col:
						if c == u"I":
							iI = index
						if c == u"A":
							iA = index
						if c == u"B":
							iB = index
						if c == u"C":
							iC = index
						if c == u"F":
							iF = index
						index = index + 1

				countline = countline + 1
			#QMessageBox.warning(None, u"Attention", str(countline)+u" lignes lues", QMessageBox.Ok)

			file.close()
				
			countfile = countfile + 1
			avancement = ((countfile*100)/total)/10
			self.dlg.progress.setProperty(u"value", avancement)

		# Stopper l edition du CSV output
		t_export_result.close()

		# Affichage d'une barre de message
		# type de barre : pushCritical, pushInfo, pushSuccess, pushWarning
		msgbar = self.iface.messageBar()
		msgbar.pushMessage(u"Geo Inspection : ", u"Traitement du(es) rapport(s) ITV terminé.", Qgis.Info,1)

#******************************************************************************************************************************************************
# Traitement GEO
#******************************************************************************************************************************************************

		total = 0
		countline = 0
		countadd = 0

		file = codecs.open(t_output, "r", encoding = 'utf-8')
		# Détermination du nombre de ligne dans le CSV à traiter
		for line in file:
			total = total + 1

		# Création d'un SHP temporaire pour le stockage des points de défaut identifiés
		temp_layer = QgsVectorLayer("Point?crs=epsg:2154", "localisation_ITV", "memory")
		pr = temp_layer.dataProvider()
		# Entrer en mode édition
		temp_layer.startEditing()
		pr.addAttributes([QgsField("id", QVariant.Int), QgsField("regard_1", QVariant.String), QgsField("regard_2", QVariant.String), QgsField("reg_depart", QVariant.String), QgsField("sens", QVariant.String), QgsField("adresse", QVariant.String), QgsField("ville", QVariant.String), QgsField("foncier", QVariant.String), QgsField("emplacemnt", QVariant.String), QgsField("date_ins", QVariant.String), QgsField("nom_ins", QVariant.String), QgsField("entreprise", QVariant.String), QgsField("norme", QVariant.String), QgsField("methode", QVariant.String), QgsField("objet", QVariant.String), QgsField("nettoyage", QVariant.String), QgsField("forme", QVariant.String), QgsField("hauteur", QVariant.Double), QgsField("materiau", QVariant.String), QgsField("prof_reg_1", QVariant.Double), QgsField("prof_reg_2", QVariant.Double), QgsField("type", QVariant.String), QgsField("utilisat", QVariant.String), QgsField("precipit", QVariant.String) ,QgsField("debit", QVariant.String), QgsField("encodage", QVariant.String), QgsField("dist_reg_1", QVariant.Double), QgsField("code", QVariant.String), QgsField("carac_1", QVariant.String), QgsField("carac_2", QVariant.String), QgsField("remarque", QVariant.String)])

		# Détermination du crs en entrée et définition d'une transformation en cas de différence avec le crs de sortie en L93
		input_crs = self.layer.crs()
		output_crs = QgsCoordinateReferenceSystem(2154)
		tr_crs = QgsCoordinateTransform(input_crs, output_crs, QgsProject.instance())

		file = codecs.open(t_output, "r", encoding = 'utf-8')
		# Boucle sur le(s) ligne(s) à traiter
		for line in file:

			col=line.split(";")
			# Détermination des regards de départ et d'arrivée
			var_amont = col[3]
			if col[1] == var_amont:
				var_aval = col[2]
			elif col[2] == var_amont:
				var_aval = col[1]
			else:
				var_aval = ""

			# Détermination des noms de champs dans le SHP réseau contenant les regards amont et aval de chaque tronçon
			field_amont="\""+ self.dlg.amont.currentText()+"\""
			field_aval="\""+ self.dlg.aval.currentText()+"\""

			# Pour tous les objets du SHP réseau, recherche du tronçon avec les regards correspondants à la ligne du CSV en cours de traitement
			for feature in self.layer.getFeatures():

				#MAJ LTA 20181214 - Faire en sorte de traiter les champs regards amont et aval du SHP de référence indifférement quelquesoit le format (str, int ou float)
				try:
					val_shp_amont = str(int(feature[self.dlg.amont.currentText()]))
				except:
					val_shp_amont = feature[self.dlg.amont.currentText()]

				try:
					val_shp_aval = str(int(feature[self.dlg.aval.currentText()]))
				except:
					val_shp_aval = feature[self.dlg.aval.currentText()]
				#FIN LTA 20181214

				if val_shp_amont == var_amont and val_shp_aval == var_aval:

					dist = float(col[26])

					if input_crs.authid() != output_crs.authid():
						feature.geometry().transform(tr_crs)

					insert_geom = feature.geometry().interpolate(dist)
					insert_feat = QgsFeature()
					insert_feat.setGeometry(insert_geom)
					insert_feat.setAttributes([col[0], col[1], col[2], col[3], col[4], col[5], col[6], col[7], col[8], col[9], col[10], col[11], col[12], col[13], col[14], col[15], col[16], col[17], col[18], col[19], col[20], col[21], col[22], col[23], col[24], col[25], col[26], col[27], col[28], col[29], col[30]])

					pr.addFeatures([insert_feat])
					countadd = countadd + 1

					break

				elif val_shp_amont == var_aval and val_shp_aval == var_amont:

					dist = float(col[26])

					if input_crs.authid() != output_crs.authid():
						feature.geometry().transform(tr_crs)

					# Inversion du sens de la géométrie courante
					nodes = feature.geometry().asPolyline()
					nodes.reverse() 
					invert_line = QgsGeometry.fromPolylineXY(nodes)

					insert_geom = invert_line.interpolate(dist)
					insert_feat = QgsFeature()
					insert_feat.setGeometry(insert_geom)
					insert_feat.setAttributes([col[0], col[1], col[2], col[3], col[4], col[5], col[6], col[7], col[8], col[9], col[10], col[11], col[12], col[13], col[14], col[15], col[16], col[17], col[18], col[19], col[20], col[21], col[22], col[23], col[24], col[25], col[26], col[27], col[28], col[29], col[30]])

					pr.addFeatures([insert_feat])
					countadd = countadd + 1

					break

			countline = countline + 1
			avancement = (((countline*100)/total)*0.9)+10
			self.dlg.progress.setProperty(u"value", avancement)

		# Sortir du mode édition
		temp_layer.commitChanges()

		file.close()

		if countadd > 0:

			# Choisir un dossier de destination
			folder = ""
			folder = str(QFileDialog.getExistingDirectory(None, u"Sélection du répertoire de destination"))
			if folder != "":
				# Déplacer le CSV
				shutil.move(t_output, folder)
				# Exporter le SHP
				writer = QgsVectorFileWriter.writeAsVectorFormat(temp_layer,folder+"//localisation_ITV_"+date+"_"+heure+".shp","utf-8",temp_layer.crs(),"ESRI Shapefile")
				# Ajouter SHP dans le canvas
				export_shp = QgsVectorLayer(folder+"//localisation_ITV_"+date+"_"+heure+".shp", "localisation_ITV_"+date+"_"+heure, "ogr")
				QgsProject.instance().addMapLayer(export_shp)
				# Ouvrir le CSV dans le mapcanvas
				export_table = QgsVectorLayer(folder+"//rapport_ITV_"+date+"_"+heure+".csv", "rapport_ITV_"+date+"_"+heure, "ogr")
				QgsProject.instance().addMapLayer(export_table)

				# Affichage d'une barre de message
				# type de barre : pushCritical, pushInfo, pushSuccess, pushWarning
				msgbar = self.iface.messageBar()
				msgbar.pushMessage(u"Geo Inspection : ", u"Le traitement s'est déroulé avec succès !", Qgis.Success,10)
			else:
				# Ajouter SHP temp dans le canvas
				QgsProject.instance().addMapLayer(temp_layer)
				# Ouvrir le CSV temp dans le mapcanvas
				export_table = QgsVectorLayer(t_output, "rapport_ITV", "ogr")
				QgsProject.instance().addMapLayer(export_table)

				# Affichage d'une barre de message
				# type de barre : pushCritical, pushInfo, pushSuccess, pushWarning
				msgbar = self.iface.messageBar()
				msgbar.pushMessage(u"Geo Inspection : ", u"Le traitement s'est déroulé avec succès !", Qgis.Success,10)
				msgbar = self.iface.messageBar()
				msgbar.pushMessage(u"Geo Inspection : ", u"Les couches en sortie sont temporaires et n'ont pas été enregistrées !", Qgis.Warning,3)
		else:
			# Affichage d'une barre de message
			# type de barre : pushCritical, pushInfo, pushSuccess, pushWarning
			msgbar = self.iface.messageBar()
			msgbar.pushMessage(u"Geo Inspection : ", u"L'exécution de l'outil a échoué, aucun fichier en sortie n'a été généré. Vérifier les données d'entrée ou le paramétrage de l'outil.", Qgis.Critical,10)

		self.dlg.company.setEnabled(False)
		self.dlg.config.setEnabled(False)
		self.dlg.shp.setEnabled(False)
		self.dlg.addshp.setEnabled(False)
		self.dlg.amont.setEnabled(False)
		self.dlg.aval.setEnabled(False)
		self.dlg.addfile.setEnabled(False)
		self.dlg.clearfile.setEnabled(False)
		self.dlg.selection.setEnabled(False)

		self.dlg.exit.show()
		self.dlg.exit.setEnabled(True)
		self.dlg.ok.hide()
		self.dlg.cancel.hide()

	def exit(self):
		reloadPlugin('GeoInspection')
